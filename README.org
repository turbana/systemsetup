#+TITLE: System Setup
#+PROPERTY: header-args :tangle no
#+STARTUP: content

Going to try out a new distro / package manager [[https://guix.gnu.org/][Guix]]. It provides a declarative
OS configuration system, transactional updates, and user level package
management.

* Commands
While learning Guix I'd like to keep some notes on how to run some commands.

NOTE: these all assume the *.scm files are located under =~/.config/guix/=.

#+BEGIN_SRC shell
  # pull down updates
  guix system pull

  # update system
  sudo guix system -L ~/.config/guix/systems reconfigure path/to/system.scm

  # list system generations
  guix system list-generations

  # roll-back system
  guix system switch-generation <n>
#+END_SRC

* Systems
Here we define the state of the base system. We'll start by defining the base
operating system that the specific hosts will inherit from.

** Base
*guix/systems/base-system.scm:*
#+BEGIN_SRC scheme :tangle guix/systems/base-system.scm
  (define-module (base-system)
    #:use-module (gnu services xorg)
    #:use-module (gnu))
  (use-service-modules desktop networking ssh xorg)

  (define-public (base-operating-system boot-uuid root-uuid swap-uuid)
    (operating-system
     (locale "en_US.utf8")
     (timezone "America/Los_Angeles")
     (keyboard-layout (keyboard-layout "us"))
     (host-name "changeme")

     (bootloader
      (bootloader-configuration
       (bootloader grub-efi-bootloader)
       (target "/boot/efi")
       (keyboard-layout keyboard-layout)))

     (file-systems
      (cons* (file-system
               (mount-point "/boot/efi")
               (device (uuid boot-uuid 'fat32))
               (type "vfat"))
             (file-system
               (mount-point "/")
               (device
                (uuid root-uuid 'ext4))
               (type "ext4"))
             %base-file-systems))

     (swap-devices
      (list (uuid swap-uuid)))

     (users (cons* (user-account
                    (name "ian")
                    (comment "Ian Clark")
                    (group "users")
                    (home-directory "/home/ian")
                    (supplementary-groups
                     '("wheel" "netdev" "audio" "video")))
                   %base-user-accounts))

     (packages
      (append
       (map specification->package
            '("git"
              ;; use i3 as a "bootstrap" wm
              "i3-wm"
              "i3status"
              "dmenu"
              "st"
              ;; ssl certs
              "nss-certs"))
       %base-packages))

     (services
      (cons*
       (service slim-service-type
                (slim-configuration
                 (xorg-configuration
                  (xorg-configuration
                   (keyboard-layout keyboard-layout)))))
       (modify-services %desktop-services
         (delete gdm-service-type))))
     ))
#+END_SRC

** tornado
*guix/systems/tornado.scm:*
#+BEGIN_SRC scheme :tangle guix/systems/tornado.scm
  (define-module (tornado)
    #:use-module (gnu)
    #:use-module (gnu services xorg)
    #:use-module (base-system))

  (use-service-modules ssh)


  (let ((parent (base-operating-system
                 "5CD3-F7B5" ;; boot uuid
                 "39406bbf-01f9-4de2-88a9-d14a90fa2e75" ;; root uuid
                 "6e9af107-9d7b-4bc2-843c-9afe9d1a4660"))) ;; swap uuid
    (operating-system
      (inherit parent)
      (host-name "tornado")

      (services
       (cons*
        ;; run an ssh server while bootstraping
        (service openssh-service-type)
        (modify-services (operating-system-user-services parent)
          ;; auto log into my wm
          (slim-service-type config =>
                             (slim-configuration
                              (inherit config)
                              (auto-login? #t)
                              (default-user "ian"))))))
      ))
#+END_SRC

** template
Here is the template we'll use for new machines. This is used with =bin/add-new-guix-maching.sh=

NOTE: This file must not end with =.scm= as =guile= will try and execute it when found on it's load path.

*guix/systems/new-machine.scm.tmpl:*
#+BEGIN_SRC scheme :tangle guix/systems/new-machine.scm.tmpl
  (define-module (<HOSTNAME>)
    #:use-module (gnu)
    #:use-module (gnu services xorg)
    #:use-module (base-system))

  (use-service-modules ssh)


  (let ((parent (base-operating-system
                 "<BOOT_UUID>" ;; boot uuid
                 "<ROOT_UUID>" ;; root uuid
                 "<SWAP_UUID>"))) ;; swap uuid
    (operating-system
      (inherit parent)
      (host-name "<HOSTNAME>")
      ))
#+END_SRC


* Sanity Check
I don't know of a way for =guix= to check that an operating system configuration is valid. So make a small file that just imports our system modules and if that doesn't raise any errors assume we're okay.

*guix/sanity-check.scm:*
#+BEGIN_SRC scheme :tangle guix/sanity-check.scm
  (define-module (sanity-check)
    #:declarative? #f
    #:use-module (gnu)
    #:use-module (ice-9 pretty-print)
    #:use-module ((base-system)
                  #:select (base-operating-system)))

  (define tornado (load "systems/tornado.scm"))

  (define (pretty-print-list L)
    (pretty-print (length L))
    (map pretty-print L))

  (define (services os)
    (map (lambda (s)
           (service-type-name (service-kind s)))
         (operating-system-services os)))


  ;; (let* (
  ;;        (base-list (services base-operating-system))
  ;;        (child-list (services tornado))
  ;;        (only-base (filter (lambda (e) (not (memq e child-list)))
  ;;                           base-list))
  ;;        (only-child (filter (lambda (e) (not (memq e base-list)))
  ;;                            child-list))
  ;;        (common (filter (lambda (e) (memq e child-list))
  ;;                        base-list))
  ;;        )
  ;;   (pretty-print "total child:")
  ;;   (pretty-print (length child-list))
  ;;   (pretty-print "total base:")
  ;;   (pretty-print (length base-list))
  ;;   (pretty-print "only child:")
  ;;   (pretty-print-list only-child)
  ;;   (pretty-print "only base:")
  ;;   (pretty-print-list only-base)
  ;;   (pretty-print "in common:")
  ;;   (pretty-print-list common)
  ;;   )

  (pretty-print-list (services tornado))
#+END_SRC

Push changes and test. Remember to =org-babel-tangle= first!
#+BEGIN_SRC shell :results output file :file out.log
  # push updates
  scp -r guix/ guix:.config/

  # check syntax errors
  ssh guix -- guile --no-auto-compile -L ~/.config/guix/systems -s ~/.config/guix/sanity-check.scm

  # check services
  # ssh guix -- guix system -L ~/.config/guix/systems extension-graph ~/.config/guix/systems/tornado.scm
#+END_SRC

#+RESULTS:
[[file:out.log]]

* Setup steps
- pull/run bootstrap.sh
- check git installed
- generate ssh key
- manually add to github
- pull all git repos
- setup symlinks
- add new machine
- guix reconfigure new machine

* Scripts
** bootstrap.sh
This is the main entry point for creating a new machine. This will need to be downloaded and executed with something like:
#+BEGIN_SRC shell :tangle no
  wget -qO ~/bootstrap.sh https://raw.githubusercontent.com/turbana/systemsetup/master/bin/bootstrap.sh && sh ~/bootstrap.sh
#+END_SRC

*bin/bootstrap.sh*
#+BEGIN_SRC shell :tangle bin/bootstrap.sh
  #!/bin/sh

  set -e

  # check for git and install
  if [ ! `which git` ]; then
      echo "* git not found, installing"
      guix package --install git
      if [ "$?" -ne "0" -o ! `which git` ]; then
          echo "* ERROR: git failed to install"
          exit 2
      fi
  fi

  repo() {
      url=$1
      path=$2
      if [ -e "$path/.git" ]; then
          echo "** repo $path already exists"
      else
          echo "** cloning repo $path"
          git clone $url $path
          if [ "$?" -eq "0" ]; then
              echo $path >> ~/github-repos-need-origin-change
          fi
      fi
  }

  # clone git repos
  echo "* clone github repos"
  repo https://github.com/turbana/systemsetup.git ~/src/systemsetup
  repo https://github.com/turbana/dotfiles.git ~/src/etc
  repo https://github.com/turbana/cpu.git ~/src/cpu
  repo https://github.com/turbana/emacs-config.git ~/src/emacs
  repo https://github.com/turbana/themian.git ~/src/themian

  # setup symlinks
  echo "* setup symlinks"
  sh ~/src/etc/setup.sh
  mkdir -p ~/.config/guix
  ln -sf ~/src/systemsetup/guix/systems ~/.config/guix/

  # add new machine
  echo "* create new guix config"
  sh ~/src/systemsetup/bin/add-new-guix-machine.sh 

  # reconfigure
  echo "* manually run the following commands to complete bootstrap:"
  echo "guix pull"
  echo "sudo guix system -L ~/.config/guix/systems reconfigure ~/.config/guix/systems/`hostname`.scm"
  echo "sudo reboot"
#+END_SRC

** add-new-guix-machine.sh
Here we add a new guix =operating-system= configuration.
#+BEGIN_SRC shell :tangle bin/add-new-guix-machine.sh
  #!/bin/sh

  set -e

  cd `dirname $0`
  template=../guix/systems/new-machine.scm.tmpl
  config=../guix/systems/`hostname`.scm

  if [ -f "$config" ]; then
      echo "** config for `hostname` already exists"
      exit 0
  fi

  find_uuid() {
      # device=`mount | grep "on $1 " | cut -f1 -d' '`
      device=/dev/`lsblk -l | grep "part ${1}$" | cut -f1 -d' '`
      for uuid in /dev/disk/by-uuid/*; do
          if [ "$device" -ef "$uuid" ]; then
              echo `basename $uuid`
              return 0
          fi
      done
      >&2 echo "* ERROR could not find UUID for mount point $1"
      return 1
  }

  HOSTNAME=`hostname`
  ROOT_UUID=`find_uuid /`
  BOOT_UUID=`find_uuid /boot/efi`
  SWAP_UUID=`find_uuid '\\[SWAP\]'`

  echo "* creating config for $HOSTNAME"
  sed -e "s/<HOSTNAME>/$HOSTNAME/g" \
      -e "s/<ROOT_UUID>/$ROOT_UUID/g" \
      -e "s/<BOOT_UUID>/$BOOT_UUID/g" \
      -e "s/<SWAP_UUID>/$SWAP_UUID/g" \
      $template > $config

  if [ ! -z "$EDITOR" ]; then
      echo "* editing config for $HOSTNAME"
      $EDITOR $config
  else
      echo "* \$EDITOR not found, manually edit file at:"
      path=`pwd`/$config
      echo `readlink -f $path`
  fi
#+END_SRC

** change-github-origin.sh
When we first checkout the github repos we use =https= rather than =ssh=. This is because we don't have a good way to add our new public ssh key into github (as we lack a web browser). So this script will go through and update the repo origins to let us commit through =ssh=.

*bin/change-github-origin.sh*
#+BEGIN_SRC shell :tangle bin/change-github-origin.sh
  #!/bin/sh

  set -e

  if [ ! -f ~/github-repos-need-origin-change ]; then
      echo "* no repos found that need origin change"
      exit 0
  fi

  # check for ssh-keygen
  if [ ! `which ssh-keygen` ]; then
      echo "* ERROR: ssh-keygen not found"
      exit 2
  fi

  # generate ssh key
  if [ ! -f $HOME/id_ecdsa ]; then
      echo " * generate ssh key"
      sudo -u $USER ssh-keygen -f /home/$USER/.ssh/id_ecdsa -t ecdsa -b 521
      echo " * MANUALLY add the public key to github"
      cat /home/$USER/.ssh/id_ecdsa.pub
      echo "Press enter to continue..."
      read ignore
  fi

  # TODO
#+END_SRC
